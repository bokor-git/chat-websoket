{"version":3,"sources":["chat.module.scss","api.ts","chat-reducer.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","api","socket","createConnection","this","io","subscribe","initMassagesHandler","newMessageSentHandler","userTypingHandler","on","destroyConnection","disconnect","sendName","name","emit","sendNewMassage","message","typeMessage","initialState","messages","typingUsers","App","useSelector","state","chat","dispatch","useDispatch","useEffect","type","messageReceived","newMessageReceived","user","typingUserAdded","massagesAnchorRef","useRef","useState","isAutoScrollActive","setIsAutoScrollActive","lastScrollTop","setLastScrollTop","current","scrollIntoView","behavior","setMessage","setName","className","style","app","onScroll","event","element","currentTarget","maxScrollPosition","scrollHeight","clientHeight","scrollTop","Math","abs","map","m","message_block","key","id","taping","ref","send_name","onClick","setClientName","placeholder","use_name","value","onChange","send_text","sendMassage","input_text","onKeyPress","Boolean","window","location","hostname","match","rootReducer","combineReducers","action","filter","u","store","createStore","applyMiddleware","thunk","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"uGACAA,EAAOC,QAAU,CAAC,IAAM,kBAAkB,KAAO,mBAAmB,OAAS,qBAAqB,cAAgB,4BAA4B,KAAO,mBAAmB,QAAU,sBAAsB,WAAa,yBAAyB,UAAY,wBAAwB,UAAY,wBAAwB,SAAW,yB,4PCCpTC,EAAM,CACfC,OAAQ,KACRC,iBAFe,WAGXC,KAAKF,OAASG,IAAG,8CAErBC,UALe,SAKLC,EACAC,EACAC,GAAyC,IAAD,MAC9C,UAAAL,KAAKF,cAAL,SAAaQ,GAAG,2BAA4BH,GAC5C,UAAAH,KAAKF,cAAL,SAAaQ,GAAG,mBAAoBF,GACpC,UAAAJ,KAAKF,cAAL,SAAaQ,GAAG,cAAeD,IAEnCE,kBAZe,WAYM,IAAD,EAChB,UAAAP,KAAKF,cAAL,SAAaU,aACbR,KAAKF,OAAS,MAElBW,SAhBe,SAgBNC,GAAe,IAAD,EACnB,UAAAV,KAAKF,cAAL,SAAaa,KAAK,mBAAoBD,IAE1CE,eAnBe,SAmBAC,GAAe,IAAD,EACzB,UAAAb,KAAKF,cAAL,SAAaa,KAAK,sBAAuBE,IAE7CC,YAtBe,WAsBA,IAAD,EACV,UAAAd,KAAKF,cAAL,SAAaa,KAAK,kBCvBpBI,EAAe,CACjBC,SAAU,GACVC,YAAa,IC+DFC,MA5Df,WACI,IAAMF,EAAWG,aAAY,SAACC,GAAD,OAAgBA,EAAMC,KAAKL,YAClDC,EAAcE,aAAY,SAACC,GAAD,OAAgBA,EAAMC,KAAKJ,eACrDK,EAAWC,cACjBC,qBAAU,WAEN,OADAF,GDuB+B,SAACA,GACpCzB,EAAIE,mBACJF,EAAIK,WAAU,SAACc,GACPM,EARY,SAACN,GAAD,MAAoB,CAACS,KAAM,oBAAqBT,YAQnDU,CAAgBV,OAC1B,SAACH,GACAS,EATe,SAACT,GAAD,MAAmB,CAACY,KAAM,uBAAwBZ,WASxDc,CAAmBd,OAEhC,SAACe,GAAD,OAAeN,EAVC,SAACM,GAAD,MAAgB,CAACH,KAAM,oBAAqBG,QAUpCC,CAAgBD,UC7BjC,WACHN,GD+B4B,SAACA,GACrCzB,EAAIU,0BC9BD,IACH,IAAMuB,EAAoBC,iBAAuB,MAVtC,EAYyCC,oBAAS,GAZlD,mBAYJC,EAZI,KAYgBC,EAZhB,OAa+BF,mBAAS,GAbxC,mBAaJG,EAbI,KAaWC,EAbX,KAeXZ,qBAAU,WACmB,IAAD,EAApBS,IACA,UAAAH,EAAkBO,eAAlB,SAA2BC,eAAe,CAACC,SAAU,cAE1D,CAACvB,IAnBO,MAoBmBgB,mBAAS,IApB5B,mBAoBJnB,EApBI,KAoBK2B,EApBL,OAqBaR,mBAAS,IArBtB,mBAqBJtB,EArBI,KAqBE+B,EArBF,KAsBX,OACI,yBAAKC,UAAWC,IAAMC,KAClB,yBAAKF,UAAWC,IAAMtB,KACjBwB,SAAU,SAACC,GACP,IAAIC,EAAUD,EAAME,cAChBC,EAAoBF,EAAQG,aAAeH,EAAQI,aACnDJ,EAAQK,UAAYjB,GAAiBkB,KAAKC,IAAIL,EAAoBF,EAAQK,WAAa,GACvFlB,GAAsB,GAEtBA,GAAsB,GAE1BE,EAAiBU,EAAME,cAAcI,aAEzCpC,EAASuC,KAAI,SAACC,GAAD,OAAY,yBAAKd,UAAWC,IAAMc,cAAeC,IAAKF,EAAEG,IAClE,0BAAMjB,UAAWC,IAAMjC,MAAO8C,EAAE5B,KAAKlB,KAArC,KACA,0BAAMgC,UAAWC,IAAM9B,SAAU2C,EAAE3C,aAEtCI,EAAYsC,KAAI,SAACC,GAAD,OAAY,yBAAKd,UAAWC,IAAMiB,OAAQF,IAAKF,EAAEG,IAAI,2BAAIH,EAAE9C,MAA/C,UAC7B,yBAAKmD,IAAK/B,KAGd,4BAAQY,UAAWC,IAAMmB,UAAWC,QAAS,WACzCzC,EDGa,SAACZ,GAAD,OAAkB,SAACY,GAC5CzB,EAAIY,SAASC,ICJQsD,CAActD,MAD3B,aAGA,2BAAOuD,YAAa,eAAgBvB,UAAWC,IAAMuB,SAAUC,MAAOzD,EAAM0D,SAAU,SAAAtB,GAAK,OAAIL,EAAQK,EAAME,cAAcmB,QAAQ1C,KAAK,SACxI,4BAAQiB,UAAWC,IAAM0B,UAAWN,QAAS,WACzCzC,EDGW,SAACT,GAAD,OAAqB,SAACS,GAC7CzB,EAAIe,eAAeC,ICJEyD,CAAYzD,IACrB2B,EAAW,MAFf,gBAIA,8BAAUyB,YAAa,kBAAmBvB,UAAWC,IAAM4B,WAAYC,WAAY,WAC/ElD,GDViB,SAACA,GAC9BzB,EAAIiB,kBCUOqD,MAAOtD,EAASuD,SAAU,SAAAtB,GAAK,OAAIN,EAAWM,EAAME,cAAcmB,YChD7DM,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,mBCRAC,EAAcC,YAChB,CAAC1D,KHJsB,WAAwC,IAAvCD,EAAsC,uDAA9BL,EAAciE,EAAgB,uCAC9D,OAAQA,EAAOvD,MACX,IAAK,oBACD,OAAO,eAAIL,EAAX,CAAkBJ,SAAUgE,EAAOhE,WAEvC,IAAK,uBACD,OAAO,eACAI,EADP,CACcJ,SAAS,GAAD,mBAAMI,EAAMJ,UAAZ,CAAsBgE,EAAOnE,UAC/CI,YAAaG,EAAMH,YAAYgE,QAAO,SAACC,GAAD,OAAYA,EAAEvB,KAAOqB,EAAOnE,QAAQe,KAAK+B,QAGvF,IAAK,oBACD,OAAO,eACAvC,EADP,CAEIH,YAAY,GAAD,mBAAMG,EAAMH,YAAYgE,QAAO,SAACC,GAAD,OAAYA,EAAEvB,KAAOqB,EAAOpD,KAAK+B,OAAhE,CAAqEqB,EAAOpD,SAG/F,QACI,OAAOR,MGZb+D,EAAQC,YAAYN,EACtBO,YAAgBC,MAMpBC,IAASC,OACL,kBAAC,IAAMC,WAAP,KACI,kBAAC,IAAD,CAAUN,MAAOA,GACb,kBAAC,EAAD,QAGRO,SAASC,eAAe,SDiHtB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAMtF,c","file":"static/js/main.f08c12f5.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"chat_app__2kSe6\",\"chat\":\"chat_chat__2Y7Jk\",\"taping\":\"chat_taping__2i4lW\",\"message_block\":\"chat_message_block__3N7S5\",\"name\":\"chat_name__2rRhU\",\"message\":\"chat_message__r3lLH\",\"input_text\":\"chat_input_text__3xNzL\",\"send_text\":\"chat_send_text__3NRSZ\",\"send_name\":\"chat_send_name__hdFTs\",\"use_name\":\"chat_use_name__ODTjQ\"};","import io from \"socket.io-client\";\r\n\r\nexport const api = {\r\n    socket: null as null | SocketIOClient.Socket,\r\n    createConnection() {\r\n        this.socket = io(\"https://chat-websoket-back.herokuapp.com/\")\r\n    },\r\n    subscribe(initMassagesHandler: (messages: any) => void,\r\n              newMessageSentHandler: (message: any) => void,\r\n              userTypingHandler: (user: any) => void) {\r\n        this.socket?.on(\"innit-massaged-published\", initMassagesHandler)\r\n        this.socket?.on('new-message-sent', newMessageSentHandler)\r\n        this.socket?.on(\"user-typing\", userTypingHandler)\r\n    },\r\n    destroyConnection() {\r\n        this.socket?.disconnect();\r\n        this.socket = null\r\n    },\r\n    sendName(name: string) {\r\n        this.socket?.emit(\"client-name-sent\", name);\r\n    },\r\n    sendNewMassage(message: any) {\r\n        this.socket?.emit(\"client-message-sent\", message);\r\n    },\r\n    typeMessage() {\r\n        this.socket?.emit(\"client-typed\");\r\n    }\r\n}","import {api} from \"./api\";\r\n\r\nconst initialState = {\r\n    messages: [],\r\n    typingUsers: []\r\n}\r\n\r\nexport const chatReducer = (state = initialState, action: any) => {\r\n    switch (action.type) {\r\n        case \"messages-received\": {\r\n            return {...state, messages: action.messages}\r\n        }\r\n        case \"new-message-received\": {\r\n            return {\r\n                ...state, messages: [...state.messages, action.message],\r\n                typingUsers: state.typingUsers.filter((u: any) => u.id !== action.message.user.id)\r\n            }\r\n        }\r\n        case \"typing-user-added\": {\r\n            return {\r\n                ...state,\r\n                typingUsers: [...state.typingUsers.filter((u: any) => u.id !== action.user.id), action.user]\r\n            }\r\n        }\r\n        default:\r\n            return state\r\n\r\n    }\r\n}\r\n\r\nconst messageReceived = (messages: any) => ({type: \"messages-received\", messages})\r\nconst newMessageReceived = (message: any) => ({type: \"new-message-received\", message})\r\nconst typingUserAdded = (user: any) => ({type: \"typing-user-added\", user})\r\n\r\n\r\nexport const createConnections = () => (dispatch: any) => {\r\n    api.createConnection()\r\n    api.subscribe((messages: any) => {\r\n            dispatch(messageReceived(messages))\r\n        }, (message: any) => {\r\n            dispatch(newMessageReceived(message))\r\n        },\r\n        (user: any) => dispatch(typingUserAdded(user)))\r\n}\r\n\r\nexport const destroyConnections = () => (dispatch: any) => {\r\n    api.destroyConnection()\r\n}\r\n\r\nexport const typeMessage = () => (dispatch: any) => {\r\n    api.typeMessage()\r\n}\r\n\r\n\r\nexport const setClientName = (name: string) => (dispatch: any) => {\r\n    api.sendName(name)\r\n}\r\n\r\nexport const sendMassage = (message: string) => (dispatch: any) => {\r\n    api.sendNewMassage(message)\r\n}","import React, {useEffect, useRef, useState} from 'react';\nimport './App.css';\nimport style from \"./chat.module.scss\"\nimport {useDispatch, useSelector} from \"react-redux\"\nimport {createConnections, destroyConnections, sendMassage, setClientName, typeMessage} from \"./chat-reducer\";\n\n\nfunction App() {\n    const messages = useSelector((state: any) => state.chat.messages)\n    const typingUsers = useSelector((state: any) => state.chat.typingUsers)\n    const dispatch = useDispatch()\n    useEffect(() => {\n        dispatch(createConnections());\n        return () => {\n            dispatch(destroyConnections())\n        }\n    }, [])\n    const massagesAnchorRef = useRef<HTMLDivElement>(null)\n    //const [messages, setMessages] = useState<Array<any>>([])\n    const [isAutoScrollActive, setIsAutoScrollActive] = useState(true)\n    const [lastScrollTop, setLastScrollTop] = useState(0)\n\n    useEffect(() => {\n        if (isAutoScrollActive) {\n            massagesAnchorRef.current?.scrollIntoView({behavior: \"smooth\"})\n        }\n    }, [messages])\n    const [message, setMessage] = useState(\"\")\n    const [name, setName] = useState(\"\")\n    return (\n        <div className={style.app}>\n            <div className={style.chat}\n                 onScroll={(event) => {\n                     let element = event.currentTarget\n                     let maxScrollPosition = element.scrollHeight - element.clientHeight\n                     if (element.scrollTop > lastScrollTop && Math.abs(maxScrollPosition - element.scrollTop) < 15) {\n                         setIsAutoScrollActive(true)\n                     } else {\n                         setIsAutoScrollActive(false)\n                     }\n                     setLastScrollTop(event.currentTarget.scrollTop)\n                 }}>\n                {messages.map((m: any) => <div className={style.message_block} key={m.id}>\n                    <span className={style.name}>{m.user.name}:</span>\n                    <span className={style.message}>{m.message}</span>\n                    </div>)}\n                {typingUsers.map((m: any) => <div className={style.taping} key={m.id}><b>{m.name}</b>...</div>)}\n                <div ref={massagesAnchorRef}></div>\n\n            </div>\n            <button className={style.send_name} onClick={() => {\n                dispatch(setClientName(name))\n            }}>Use name:</button>\n            <input placeholder={\"Your name...\"} className={style.use_name} value={name} onChange={event => setName(event.currentTarget.value)} type=\"text\"/>\n            <button className={style.send_text} onClick={() => {\n                dispatch(sendMassage(message));\n                setMessage(\"\")\n            }}>Send message</button>\n            <textarea placeholder={\"Your message...\"} className={style.input_text} onKeyPress={() => {\n                dispatch(typeMessage())\n            }} value={message} onChange={event => setMessage(event.currentTarget.value)}></textarea>\n\n        </div>\n    );\n}\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport {Provider} from \"react-redux\";\nimport {applyMiddleware, combineReducers, createStore} from \"redux\";\nimport {chatReducer} from \"./chat-reducer\";\nimport thunk from \"redux-thunk\";\n\nconst rootReducer = combineReducers(\n    {chat: chatReducer})\n\nconst store = createStore(rootReducer,\n    applyMiddleware(thunk)\n)\n\nexport type AppStateType = ReturnType<typeof rootReducer>\n\n\nReactDOM.render(\n    <React.StrictMode>\n        <Provider store={store}>\n            <App/>\n        </Provider>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}